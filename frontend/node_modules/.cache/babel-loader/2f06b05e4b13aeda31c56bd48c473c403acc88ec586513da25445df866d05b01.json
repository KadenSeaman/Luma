{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\kaden\\\\Documents\\\\Web Development\\\\Luma\\\\src\\\\components\\\\renderer.js\",\n  _s = $RefreshSig$();\nimport '../styles/renderer.scss';\nimport { AppContext } from \"../context/appContext\";\nimport { RendererProvider } from '../context/rendererContext';\nimport { useContext, useEffect, useRef, useState } from 'react';\nimport { Queue } from '@datastructures-js/queue';\nimport Viewport from './viewport';\nimport Node from './node';\nimport Edge from './edge';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction Renderer() {\n  return /*#__PURE__*/_jsxDEV(RendererProvider, {\n    children: /*#__PURE__*/_jsxDEV(RendererContent, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 16,\n      columnNumber: 13\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 15,\n    columnNumber: 9\n  }, this);\n}\n_c = Renderer;\nfunction RendererContent() {\n  _s();\n  var _renderer$current, _renderer$current2;\n  const renderer = useRef(null);\n  const textRuler = useRef(null);\n  const {\n    rendererHeight,\n    rendererWidth,\n    rootNode,\n    forceRender\n  } = useContext(AppContext);\n  const [formattedNodeData, setFormattedNodeData] = useState([]);\n  const [formattedEdgeData, setFormattedEdgeData] = useState([]);\n  const rendererStyle = {\n    width: `${rendererWidth}vw`,\n    height: `${rendererHeight}vh`\n  };\n  useEffect(() => {\n    /*\r\n        Modified Sugiyama Method\r\n          1. Seperate all non connected graphs into their own components\r\n        2. Break all cycles within a componenet\r\n        3. Assign levels based upon hierarchy\r\n        4. Create dummy nodes for edges that span multiple levels\r\n        5. Reduce crossing \r\n    */\n\n    const calculatePositions = () => {\n      // estimate size of node\n      assignNodeSizes();\n\n      // assign unique ids to each node and return a map of id to node and node name to id\n      const [nodeIdToNode, nodeNameToId] = assignNodeIds();\n\n      // create an adjList of all nodes and edges\n      const adjList = createAdjList(nodeNameToId);\n\n      // create an adjList where each key is node and the values are incoming edges\n      const incomingAdjList = createIncomingAdjList(nodeNameToId);\n\n      // seperate all nodes into connected components\n      const components = createSeperateComponents(adjList, incomingAdjList);\n\n      // create a minimum feedback arc set which is acyclic and the minimum amount of edges have been reversed to eliminate cycles\n      const fasGraphs = [];\n      for (const component of components) fasGraphs.push(createFASGraph(component, incomingAdjList));\n\n      // assign levels to each non acyclic graph\n      const levels = [];\n      for (const acyclicGraph of fasGraphs) levels.push(assignLevel(acyclicGraph, nodeIdToNode));\n\n      // create dummy nodes so edges span max 1 layer\n      const dummyGraph = [];\n      const dummyLevels = [];\n      for (let i = 0; i < fasGraphs.length; i++) {\n        const [graphRes, levelRes] = insertDummyNodes(fasGraphs[i], levels[i]);\n        dummyGraph.push(graphRes);\n        dummyLevels.push(levelRes);\n      }\n\n      // turn the levels map into array so you can assign an ordering\n      const orderedLevels = [];\n      for (const level of dummyLevels) {\n        orderedLevels.push(convertLevelsToArray(level));\n      }\n\n      // reduce edge crossings\n      const optimizedLevels = [];\n      for (let i = 0; i < dummyGraph.length; i++) {\n        const optimizedLevel = minimizeEdgeCrossings(dummyGraph[i], orderedLevels[i]);\n        optimizedLevels.push(optimizedLevel);\n      }\n      let componentOffsetX = 0;\n      let componentOffsetY = 0;\n      for (let i = 0; i < optimizedLevels.length; i++) {\n        const [curComponentWidth, curComponentHeight] = assignPositions(optimizedLevels[i], nodeIdToNode, componentOffsetX);\n        componentOffsetX += curComponentWidth;\n        componentOffsetY += curComponentHeight;\n      }\n      assignPaths(nodeIdToNode, nodeNameToId);\n      setFormattedNodeData(rootNode.nodes);\n      setFormattedEdgeData(rootNode.edges);\n      forceRender();\n    };\n    const assignPaths = (nodeIdToNode, nodeNameToId) => {\n      for (const edge of rootNode.edges || []) {\n        if (!nodeNameToId.has(edge.source) || !nodeNameToId.has(edge.target)) continue;\n        const sourceId = nodeNameToId.get(edge.source);\n        const targetId = nodeNameToId.get(edge.target);\n        const sourceNode = nodeIdToNode.get(sourceId);\n        const targetNode = nodeIdToNode.get(targetId);\n        edge.rootX = sourceNode.x + sourceNode.width / 2;\n        edge.rootY = sourceNode.y + sourceNode.height / 2;\n        edge.targetX = targetNode.x + targetNode.width / 2;\n        edge.targetY = targetNode.y + targetNode.height / 2;\n      }\n    };\n    const assignPositions = (levels, nodeIdToNode, componentOffsetX) => {\n      let componentWidth = 0;\n      let componentHeight = 0;\n\n      // loop through each level\n      let levelYOffset = 0;\n      const Y_PADDING = 100;\n      const X_PADDING = 100;\n      for (let i = 0; i < levels.length; i++) {\n        // get max height of a node to make sure the entire level can contain it\n        let maxHeight = 0;\n        let levelXOffset = 0;\n        for (const nodeId of levels[i]) {\n          maxHeight = Math.max(maxHeight, nodeIdToNode.get(nodeId).height);\n        }\n        for (const nodeId of levels[i]) {\n          const node = nodeIdToNode.get(nodeId);\n          node.x = levelXOffset + componentOffsetX;\n          node.y = levelYOffset + Y_PADDING;\n          levelXOffset += node.width + X_PADDING;\n        }\n        levelYOffset += maxHeight + Y_PADDING;\n\n        // component height = sum of all max heights of every level \n        componentHeight += maxHeight;\n        componentWidth = Math.max(componentWidth, levelXOffset);\n      }\n      return [componentWidth, componentHeight];\n    };\n    const convertLevelsToArray = levels => {\n      const deepestLevel = Math.max(...levels.values());\n      const orderedLevels = [];\n      for (let i = 0; i <= deepestLevel; i++) {\n        orderedLevels.push([]);\n      }\n      for (const [id, level] of levels) {\n        orderedLevels[level].push(id);\n      }\n      return orderedLevels;\n    };\n    const minimizeEdgeCrossings = (adjList, levels) => {\n      let cycles = 0;\n      while (cycles < 4) {\n        for (let i = 1; i < levels.length; i++) {\n          const currentLayer = levels[i];\n          const prevLayer = levels[i - 1];\n          const barycenters = new Map();\n          for (const nodeId of currentLayer) {\n            const neighbors = adjList.get(nodeId);\n            let sum = 0;\n            let count = 0;\n            for (const neighborId of neighbors) {\n              if (prevLayer.includes(neighborId)) {\n                sum += prevLayer.indexOf(neighborId);\n                count++;\n              }\n            }\n            const barycenter = count > 0 ? sum / count : 0;\n            barycenters.set(nodeId, barycenter);\n          }\n          currentLayer.sort((a, b) => barycenters.get(a) - barycenters.get(b));\n        }\n        for (let i = levels.length - 2; i >= 0; i--) {\n          const currentLayer = levels[i];\n          const prevLayer = levels[i + 1];\n          const barycenters = new Map();\n          for (const nodeId of currentLayer) {\n            const neighbors = adjList.get(nodeId);\n            let count = 0;\n            let sum = 0;\n            for (const neighborId of neighbors) {\n              if (prevLayer.includes(neighborId)) {\n                sum += prevLayer.indexOf(neighborId);\n                count++;\n              }\n            }\n            const barycenter = count > 0 ? sum / count : 0;\n            barycenters.set(nodeId, barycenter);\n          }\n          currentLayer.sort((a, b) => barycenters.get(a) - barycenters.get(b));\n        }\n        cycles++;\n      }\n      return levels;\n    };\n    const insertDummyNodes = (adjList, levels) => {\n      const newAdjList = new Map(adjList); // copy original adjList\n      const newLevels = new Map(levels); // copy the original levels\n\n      // iterate through all nodes in adj list\n      for (const nodeId of adjList.keys()) {\n        const updatedNeighbors = new Set();\n\n        // iterate through each neighbor of current node\n        for (const neiId of adjList.get(nodeId)) {\n          const startLevel = levels.get(nodeId);\n          const endLevel = levels.get(neiId);\n\n          // if edge is spans more than 1 level, insert dummy nodes\n          if (endLevel > startLevel + 1) {\n            let prevNodeId = nodeId;\n\n            // start isnserting dummy nodes at intermediate levels\n            for (let level = startLevel + 1; level < endLevel; level++) {\n              const dummyNodeId = `Dummy_${nodeId}_${neiId}_${level}`;\n\n              // add the dummy node to the new adjlist\n              newAdjList.set(dummyNodeId, new Set());\n\n              // add the dummy node to the new levels map\n              newLevels.set(dummyNodeId, level);\n\n              // connect the previous node to the dummy node\n              newAdjList.get(prevNodeId).add(dummyNodeId);\n\n              // update the previous node to teh current dummy node\n              prevNodeId = dummyNodeId;\n            }\n            newAdjList.get(prevNodeId).add(neiId);\n          } else {\n            updatedNeighbors.add(neiId);\n          }\n        }\n        newAdjList.set(nodeId, updatedNeighbors);\n      }\n      return [newAdjList, newLevels];\n    };\n    const assignNodeSizes = () => {\n      for (const node of rootNode.nodes || []) {\n        if (!textRuler.current) return;\n        let calculatedWidth = 0;\n        let calculatedHeight = 0;\n        const canvas = textRuler.current;\n        const ctx = canvas.getContext(\"2d\");\n\n        // estimate title size\n        const title = node.name;\n        ctx.font = `${node.fontSize * 2}px Arial`;\n        const titleMeasurements = ctx.measureText(title);\n        const titleWidth = titleMeasurements.width;\n        ;\n        calculatedWidth = Math.max(calculatedWidth, titleWidth);\n        calculatedHeight += node.fontSize * 2 * 1.25 + node.fontSize * 1.25 * 2 + 16; // title is 2em\n\n        // estimate width of fields\n        ctx.font = `${node.fontSize}px Arial`;\n        for (const field of node.fields) {\n          const fieldMeasurement = ctx.measureText(field.toString());\n          calculatedWidth = Math.max(calculatedWidth, fieldMeasurement.width);\n          calculatedHeight += node.fontSize * 1.25 + node.fontSize * 2;\n        }\n\n        // estimate width of methods\n        for (const method of node.methods) {\n          const methodMeasurement = ctx.measureText(method.toString());\n          calculatedWidth = Math.max(calculatedWidth, methodMeasurement.width);\n          calculatedHeight += node.fontSize * 1.25 + node.fontSize * 2;\n        }\n        node.width = Math.max(100, calculatedWidth + node.padding * 2);\n        node.height = Math.max(100, calculatedHeight + node.padding * 2);\n      }\n    };\n    const assignNodeIds = () => {\n      const nodeIdToNode = new Map();\n      const nodeNameToId = new Map();\n      let nodeCount = 0;\n      for (const node of rootNode.nodes || []) {\n        node.id = `n${nodeCount}`;\n        nodeIdToNode.set(node.id, node);\n        nodeNameToId.set(node.name, node.id);\n        nodeCount++;\n      }\n      return [nodeIdToNode, nodeNameToId];\n    };\n    const createSeperateComponents = (adjList, incomingAdjList) => {\n      const visited = new Set();\n      const components = [];\n      const dfs = (nodeId, graphMap) => {\n        if (visited.has(nodeId)) return;\n        visited.add(nodeId);\n        graphMap.set(nodeId, adjList.get(nodeId));\n        for (const neiId of graphMap.get(nodeId)) {\n          dfs(neiId, graphMap);\n        }\n        for (const neiId of incomingAdjList.get(nodeId)) {\n          dfs(neiId, graphMap);\n        }\n        return graphMap;\n      };\n      for (const node of rootNode.nodes || []) {\n        const nodeId = node.id;\n        if (visited.has(nodeId)) continue;\n        components.push(dfs(nodeId, new Map()));\n      }\n      return components;\n    };\n    const createAdjList = nodeNameToId => {\n      const adjList = new Map();\n      for (const node of rootNode.nodes || []) {\n        adjList.set(node.id, new Set());\n      }\n      for (const edge of rootNode.edges || []) {\n        const sourceId = nodeNameToId.get(edge.source);\n        const targetId = nodeNameToId.get(edge.target);\n        if (sourceId === undefined || targetId === undefined) continue;\n        adjList.get(sourceId).add(targetId);\n      }\n      return adjList;\n    };\n    const createIncomingAdjList = nodeNameToId => {\n      const adjList = new Map();\n      for (const node of rootNode.nodes || []) {\n        adjList.set(node.id, new Set());\n      }\n      for (const edge of rootNode.edges || []) {\n        const sourceId = nodeNameToId.get(edge.source);\n        const targetId = nodeNameToId.get(edge.target);\n        if (sourceId === undefined || targetId === undefined) continue;\n        adjList.get(targetId).add(sourceId);\n      }\n      return adjList;\n    };\n    const createFASGraph = (adjList, incomingAdjList) => {\n      const visited = new Set();\n      const dfs = nodeId => {\n        if (visited.has(nodeId)) {\n          greedyMakeAcyclic(nodeId, adjList, incomingAdjList);\n        }\n        visited.add(nodeId);\n        for (const targetId of adjList.get(nodeId) || []) {\n          dfs(targetId);\n        }\n      };\n      for (const nodeId of adjList.keys()) {\n        if (visited.has(nodeId)) continue;\n        dfs(nodeId);\n      }\n      return adjList;\n    };\n    const greedyMakeAcyclic = (nodeId, adjList, incomingAdjList) => {\n      const outgoingEdges = adjList.get(nodeId);\n      const incomingEdges = incomingAdjList.get(nodeId);\n\n      // np O (n + m) where n is incoming and m is outgoing\n\n      if (outgoingEdges.length > incomingEdges.length) {\n        // flip incoming to outgoing\n        for (const incomingId of incomingEdges) {\n          // remove incoming edge\n          adjList.get(incomingId).delete(nodeId);\n          // add new outgoing in place\n          adjList.get(nodeId).add(incomingId);\n        }\n      } else {\n        // flip outgoing to incoming\n        for (const outgoingId of outgoingEdges) {\n          // remove outgoing edge\n          adjList.get(nodeId).delete(outgoingId);\n\n          // add new incoming in place\n          adjList.get(outgoingId).add(nodeId);\n        }\n      }\n    };\n    const assignLevel = adjList => {\n      const topologicalSort = () => {\n        const inDegree = new Map();\n        for (const nodeId of adjList.keys()) {\n          inDegree.set(nodeId, 0);\n        }\n        for (const neiIdSet of adjList.values()) {\n          for (const neiId of neiIdSet) {\n            inDegree.set(neiId, inDegree.get(neiId) + 1);\n          }\n        }\n        const queue = new Queue();\n        for (const nodeId of inDegree.keys()) {\n          if (inDegree.get(nodeId) === 0) queue.push(nodeId);\n        }\n        const topologicalOrder = [];\n        while (!queue.isEmpty()) {\n          const nodeId = queue.pop();\n          topologicalOrder.push(nodeId);\n          for (const neiId of adjList.get(nodeId)) {\n            inDegree.set(neiId, inDegree.get(neiId) - 1);\n            if (inDegree.get(neiId) === 0) {\n              queue.push(neiId);\n            }\n          }\n        }\n        return topologicalOrder;\n      };\n\n      // use kahns algorithm to process nodes by level\n      const topoSorted = topologicalSort();\n\n      // assign levels to nodes\n      const levels = new Map();\n      for (const nodeId of topoSorted) {\n        let maxPredLevel = -1;\n        for (const pred of adjList.keys().filter(n => adjList.get(n).has(nodeId))) {\n          if (levels.get(pred) > maxPredLevel) {\n            maxPredLevel = levels.get(pred);\n          }\n        }\n        levels.set(nodeId, maxPredLevel + 1);\n      }\n      return levels;\n    };\n    if (rootNode) calculatePositions();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [rootNode]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: renderer,\n    id: \"renderer\",\n    style: rendererStyle,\n    children: [/*#__PURE__*/_jsxDEV(Viewport, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 546,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"svg\", {\n      xmlns: \"http://www.w3.org/2000/svg\",\n      preserveAspectRatio: \"xMidYMid meet\",\n      viewBox: `0 0 ${(_renderer$current = renderer.current) === null || _renderer$current === void 0 ? void 0 : _renderer$current.offsetWidth} ${(_renderer$current2 = renderer.current) === null || _renderer$current2 === void 0 ? void 0 : _renderer$current2.offsetHeight}`,\n      id: \"edge-container\",\n      children: formattedEdgeData.length > 0 && (formattedEdgeData || []).map((edge, i) => /*#__PURE__*/_jsxDEV(Edge, {\n        data: edge\n      }, i, false, {\n        fileName: _jsxFileName,\n        lineNumber: 548,\n        columnNumber: 93\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 547,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      id: \"node-container\",\n      children: formattedNodeData.length > 0 && (formattedNodeData || []).map((node, i) => /*#__PURE__*/_jsxDEV(Node, {\n        data: node\n      }, i, false, {\n        fileName: _jsxFileName,\n        lineNumber: 551,\n        columnNumber: 93\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 550,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n      id: \"text-calculator\",\n      ref: textRuler\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 553,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 545,\n    columnNumber: 9\n  }, this);\n}\n_s(RendererContent, \"C79y3ojVRbsm2oag3rTArLw57zo=\");\n_c2 = RendererContent;\nexport default Renderer;\nvar _c, _c2;\n$RefreshReg$(_c, \"Renderer\");\n$RefreshReg$(_c2, \"RendererContent\");","map":{"version":3,"names":["AppContext","RendererProvider","useContext","useEffect","useRef","useState","Queue","Viewport","Node","Edge","jsxDEV","_jsxDEV","Renderer","children","RendererContent","fileName","_jsxFileName","lineNumber","columnNumber","_c","_s","_renderer$current","_renderer$current2","renderer","textRuler","rendererHeight","rendererWidth","rootNode","forceRender","formattedNodeData","setFormattedNodeData","formattedEdgeData","setFormattedEdgeData","rendererStyle","width","height","calculatePositions","assignNodeSizes","nodeIdToNode","nodeNameToId","assignNodeIds","adjList","createAdjList","incomingAdjList","createIncomingAdjList","components","createSeperateComponents","fasGraphs","component","push","createFASGraph","levels","acyclicGraph","assignLevel","dummyGraph","dummyLevels","i","length","graphRes","levelRes","insertDummyNodes","orderedLevels","level","convertLevelsToArray","optimizedLevels","optimizedLevel","minimizeEdgeCrossings","componentOffsetX","componentOffsetY","curComponentWidth","curComponentHeight","assignPositions","assignPaths","nodes","edges","edge","has","source","target","sourceId","get","targetId","sourceNode","targetNode","rootX","x","rootY","y","targetX","targetY","componentWidth","componentHeight","levelYOffset","Y_PADDING","X_PADDING","maxHeight","levelXOffset","nodeId","Math","max","node","deepestLevel","values","id","cycles","currentLayer","prevLayer","barycenters","Map","neighbors","sum","count","neighborId","includes","indexOf","barycenter","set","sort","a","b","newAdjList","newLevels","keys","updatedNeighbors","Set","neiId","startLevel","endLevel","prevNodeId","dummyNodeId","add","current","calculatedWidth","calculatedHeight","canvas","ctx","getContext","title","name","font","fontSize","titleMeasurements","measureText","titleWidth","field","fields","fieldMeasurement","toString","method","methods","methodMeasurement","padding","nodeCount","visited","dfs","graphMap","undefined","greedyMakeAcyclic","outgoingEdges","incomingEdges","incomingId","delete","outgoingId","topologicalSort","inDegree","neiIdSet","queue","topologicalOrder","isEmpty","pop","topoSorted","maxPredLevel","pred","filter","n","ref","style","xmlns","preserveAspectRatio","viewBox","offsetWidth","offsetHeight","map","data","_c2","$RefreshReg$"],"sources":["C:/Users/kaden/Documents/Web Development/Luma/src/components/renderer.js"],"sourcesContent":["import '../styles/renderer.scss';\r\n\r\nimport { AppContext } from \"../context/appContext\";\r\nimport { RendererProvider } from '../context/rendererContext';\r\n\r\nimport { useContext, useEffect, useRef, useState } from 'react';\r\nimport { Queue } from '@datastructures-js/queue';\r\n\r\nimport Viewport from './viewport';\r\nimport Node from './node';\r\nimport Edge from './edge';\r\n\r\nfunction Renderer() {\r\n    return (\r\n        <RendererProvider>\r\n            <RendererContent />\r\n        </RendererProvider>\r\n    )\r\n}\r\n\r\nfunction RendererContent() {\r\n    const renderer = useRef(null);\r\n    const textRuler = useRef(null);\r\n    const { rendererHeight, rendererWidth, rootNode, forceRender } = useContext(AppContext);\r\n\r\n    const [formattedNodeData, setFormattedNodeData] = useState([]);\r\n    const [formattedEdgeData, setFormattedEdgeData] = useState([]);\r\n\r\n    \r\n    \r\n\r\n\r\n    const rendererStyle = {\r\n        width: `${rendererWidth}vw`,\r\n        height: `${rendererHeight}vh`,\r\n    }\r\n\r\n    useEffect(() => {\r\n\r\n        /*\r\n            Modified Sugiyama Method\r\n\r\n            1. Seperate all non connected graphs into their own components\r\n            2. Break all cycles within a componenet\r\n            3. Assign levels based upon hierarchy\r\n            4. Create dummy nodes for edges that span multiple levels\r\n            5. Reduce crossing \r\n        */\r\n\r\n        const calculatePositions = () => {\r\n            // estimate size of node\r\n            assignNodeSizes();\r\n\r\n            // assign unique ids to each node and return a map of id to node and node name to id\r\n            const [nodeIdToNode, nodeNameToId] = assignNodeIds();\r\n\r\n            // create an adjList of all nodes and edges\r\n            const adjList = createAdjList(nodeNameToId);\r\n\r\n            // create an adjList where each key is node and the values are incoming edges\r\n            const incomingAdjList = createIncomingAdjList(nodeNameToId);\r\n\r\n            // seperate all nodes into connected components\r\n            const components = createSeperateComponents(adjList, incomingAdjList);\r\n\r\n            // create a minimum feedback arc set which is acyclic and the minimum amount of edges have been reversed to eliminate cycles\r\n            const fasGraphs = [];\r\n            for(const component of components) fasGraphs.push(createFASGraph(component, incomingAdjList));\r\n\r\n            // assign levels to each non acyclic graph\r\n            const levels = [];\r\n            for(const acyclicGraph of fasGraphs) levels.push(assignLevel(acyclicGraph, nodeIdToNode));\r\n\r\n            // create dummy nodes so edges span max 1 layer\r\n            const dummyGraph = [];\r\n            const dummyLevels = [];\r\n\r\n            for(let i = 0; i < fasGraphs.length; i++){\r\n                const [graphRes, levelRes] = insertDummyNodes(fasGraphs[i], levels[i]); \r\n\r\n                dummyGraph.push(graphRes);\r\n                dummyLevels.push(levelRes);\r\n            }\r\n\r\n\r\n            // turn the levels map into array so you can assign an ordering\r\n            const orderedLevels = [];\r\n            \r\n            for(const level of dummyLevels){\r\n                orderedLevels.push(convertLevelsToArray(level));\r\n            }\r\n\r\n            // reduce edge crossings\r\n            const optimizedLevels = [];\r\n\r\n            for(let i = 0; i < dummyGraph.length; i++){\r\n                const optimizedLevel = minimizeEdgeCrossings(dummyGraph[i], orderedLevels[i]);\r\n                optimizedLevels.push(optimizedLevel);\r\n            }\r\n\r\n            let componentOffsetX = 0;\r\n            let componentOffsetY = 0;\r\n\r\n            for(let i = 0; i < optimizedLevels.length; i++){\r\n                const [curComponentWidth, curComponentHeight] = assignPositions(optimizedLevels[i], nodeIdToNode, componentOffsetX);\r\n\r\n                componentOffsetX += curComponentWidth;\r\n                componentOffsetY += curComponentHeight;\r\n            }\r\n\r\n            assignPaths(nodeIdToNode, nodeNameToId);\r\n\r\n            setFormattedNodeData(rootNode.nodes);\r\n            setFormattedEdgeData(rootNode.edges);\r\n            forceRender();\r\n        }\r\n\r\n        const assignPaths = (nodeIdToNode, nodeNameToId) => {\r\n            for(const edge of rootNode.edges || []){\r\n                if(!nodeNameToId.has(edge.source) || !nodeNameToId.has(edge.target)) continue;\r\n\r\n                const sourceId = nodeNameToId.get(edge.source);\r\n                const targetId = nodeNameToId.get(edge.target);\r\n\r\n                const sourceNode = nodeIdToNode.get(sourceId);\r\n                const targetNode = nodeIdToNode.get(targetId);\r\n\r\n                edge.rootX = sourceNode.x + sourceNode.width / 2;\r\n                edge.rootY = sourceNode.y + sourceNode.height / 2;\r\n                edge.targetX = targetNode.x + targetNode.width / 2;\r\n                edge.targetY = targetNode.y + targetNode.height / 2;\r\n            }\r\n        }\r\n\r\n        const assignPositions = (levels, nodeIdToNode, componentOffsetX) => {\r\n            let componentWidth = 0;\r\n            let componentHeight = 0;\r\n\r\n            // loop through each level\r\n            let levelYOffset = 0;\r\n\r\n            const Y_PADDING = 100;\r\n            const X_PADDING = 100;\r\n\r\n            for(let i = 0; i < levels.length; i++){\r\n                // get max height of a node to make sure the entire level can contain it\r\n                let maxHeight = 0;\r\n                let levelXOffset = 0;\r\n\r\n                for(const nodeId of levels[i]){\r\n                    maxHeight = Math.max(maxHeight, nodeIdToNode.get(nodeId).height)\r\n                }\r\n\r\n                for(const nodeId of levels[i]){\r\n                    const node = nodeIdToNode.get(nodeId);\r\n\r\n                    node.x = levelXOffset + componentOffsetX;\r\n                    node.y = levelYOffset + Y_PADDING;\r\n\r\n                    levelXOffset += node.width + X_PADDING;\r\n                }\r\n\r\n                levelYOffset += maxHeight + Y_PADDING;\r\n\r\n                // component height = sum of all max heights of every level \r\n                componentHeight += maxHeight;\r\n                componentWidth = Math.max(componentWidth, levelXOffset);\r\n            }\r\n\r\n            return [componentWidth, componentHeight];\r\n        }\r\n\r\n        const convertLevelsToArray = (levels) => {\r\n            const deepestLevel = Math.max(...levels.values());\r\n            const orderedLevels = [];\r\n\r\n            for(let i = 0; i <= deepestLevel; i++){\r\n                orderedLevels.push([]);\r\n            }\r\n\r\n            for(const [id, level] of levels){\r\n                orderedLevels[level].push(id);\r\n            }\r\n\r\n            return orderedLevels;\r\n        }\r\n\r\n        const minimizeEdgeCrossings = (adjList, levels) => {\r\n            let cycles = 0;\r\n\r\n            while(cycles < 4){\r\n                for(let i = 1; i < levels.length; i++){\r\n                    const currentLayer = levels[i];\r\n                    const prevLayer = levels[i - 1];\r\n\r\n                    const barycenters = new Map();\r\n\r\n                    for(const nodeId of currentLayer){\r\n                        const neighbors = adjList.get(nodeId);\r\n                        let sum = 0;\r\n                        let count = 0;\r\n                        for(const neighborId of neighbors){\r\n                            if(prevLayer.includes(neighborId)){\r\n                                sum += prevLayer.indexOf(neighborId);\r\n                                count++;\r\n                            }\r\n                        }\r\n\r\n                        const barycenter = count > 0 ? sum / count : 0;\r\n                        barycenters.set(nodeId, barycenter);\r\n                    }\r\n\r\n                    currentLayer.sort((a,b) => barycenters.get(a) - barycenters.get(b));\r\n                }\r\n\r\n                for(let i = levels.length - 2; i >= 0; i--){\r\n                    const currentLayer = levels[i];\r\n                    const prevLayer = levels[i + 1];\r\n\r\n                    const barycenters = new Map();\r\n\r\n                    for(const nodeId of currentLayer){\r\n                        const neighbors = adjList.get(nodeId);\r\n                        let count = 0;\r\n                        let sum = 0;\r\n\r\n                        for(const neighborId of neighbors){\r\n                            if(prevLayer.includes(neighborId)){\r\n                                sum += prevLayer.indexOf(neighborId);\r\n                                count++;\r\n                            }\r\n                        }\r\n\r\n                        const barycenter = count > 0 ? sum / count : 0;\r\n                        barycenters.set(nodeId,barycenter);\r\n                    }\r\n\r\n                    currentLayer.sort((a,b) => barycenters.get(a) - barycenters.get(b));\r\n                }\r\n\r\n                cycles++;\r\n            }\r\n\r\n            return levels;\r\n        }\r\n        \r\n        const insertDummyNodes = (adjList, levels) => {\r\n            const newAdjList = new Map(adjList); // copy original adjList\r\n            const newLevels = new Map(levels); // copy the original levels\r\n\r\n\r\n            // iterate through all nodes in adj list\r\n            for(const nodeId of adjList.keys()){\r\n                const updatedNeighbors = new Set();\r\n\r\n                // iterate through each neighbor of current node\r\n                for(const neiId of adjList.get(nodeId)){\r\n                    const startLevel = levels.get(nodeId);\r\n                    const endLevel = levels.get(neiId);\r\n\r\n                    // if edge is spans more than 1 level, insert dummy nodes\r\n                    if(endLevel > startLevel + 1){\r\n                        let prevNodeId = nodeId;\r\n\r\n                        // start isnserting dummy nodes at intermediate levels\r\n                        for(let level = startLevel + 1; level < endLevel; level++){\r\n                            const dummyNodeId = `Dummy_${nodeId}_${neiId}_${level}`;\r\n\r\n                            // add the dummy node to the new adjlist\r\n                            newAdjList.set(dummyNodeId, new Set());\r\n\r\n                            // add the dummy node to the new levels map\r\n                            newLevels.set(dummyNodeId, level);\r\n\r\n                            // connect the previous node to the dummy node\r\n                            newAdjList.get(prevNodeId).add(dummyNodeId);\r\n\r\n                            // update the previous node to teh current dummy node\r\n                            prevNodeId = dummyNodeId;\r\n                        }\r\n\r\n                        newAdjList.get(prevNodeId).add(neiId);\r\n                    }\r\n                    else {\r\n                        updatedNeighbors.add(neiId);\r\n                    }\r\n                }\r\n\r\n                newAdjList.set(nodeId, updatedNeighbors);\r\n            }\r\n\r\n            return [newAdjList, newLevels];\r\n        }\r\n\r\n        const assignNodeSizes = () => {\r\n            for(const node of rootNode.nodes || []){\r\n                if(!textRuler.current) return;\r\n    \r\n                let calculatedWidth = 0;\r\n                let calculatedHeight = 0;\r\n    \r\n                const canvas = textRuler.current;      \r\n                const ctx = canvas.getContext(\"2d\");\r\n    \r\n    \r\n                // estimate title size\r\n                const title = node.name;\r\n                ctx.font = `${node.fontSize * 2}px Arial`;\r\n                const titleMeasurements = ctx.measureText(title);\r\n    \r\n                const titleWidth = titleMeasurements.width;;\r\n            \r\n                calculatedWidth = Math.max(calculatedWidth, titleWidth);\r\n                calculatedHeight += node.fontSize * 2 * 1.25 + node.fontSize * 1.25 * 2 + 16; // title is 2em\r\n    \r\n    \r\n    \r\n                // estimate width of fields\r\n                ctx.font = `${node.fontSize}px Arial`;\r\n                for(const field of node.fields){\r\n                    const fieldMeasurement = ctx.measureText(field.toString());\r\n    \r\n                    calculatedWidth = Math.max(calculatedWidth, fieldMeasurement.width);\r\n                    calculatedHeight += node.fontSize * 1.25 + node.fontSize * 2;\r\n                }\r\n    \r\n                // estimate width of methods\r\n                for(const method of node.methods){\r\n                    const methodMeasurement = ctx.measureText(method.toString());\r\n    \r\n                    calculatedWidth = Math.max(calculatedWidth, methodMeasurement.width);\r\n                    calculatedHeight += node.fontSize * 1.25 + node.fontSize * 2;\r\n                }\r\n    \r\n    \r\n                node.width = Math.max(100, calculatedWidth + node.padding * 2);\r\n                node.height = Math.max(100, calculatedHeight + node.padding * 2);\r\n            }\r\n        }\r\n\r\n        const assignNodeIds = () => {\r\n            const nodeIdToNode = new Map();\r\n            const nodeNameToId = new Map();\r\n\r\n            let nodeCount = 0;\r\n\r\n            for(const node of rootNode.nodes || []){\r\n                node.id = `n${nodeCount}`;\r\n                nodeIdToNode.set(node.id, node);\r\n                nodeNameToId.set(node.name, node.id);\r\n                nodeCount++;\r\n            }\r\n\r\n            return [nodeIdToNode, nodeNameToId];\r\n        }\r\n\r\n        const createSeperateComponents = (adjList, incomingAdjList) => {\r\n            const visited = new Set();\r\n\r\n            const components = [];\r\n\r\n            const dfs = (nodeId, graphMap) => {\r\n                if(visited.has(nodeId)) return;\r\n                visited.add(nodeId);\r\n\r\n                graphMap.set(nodeId, adjList.get(nodeId));\r\n\r\n                for(const neiId of graphMap.get(nodeId)){\r\n                    dfs(neiId, graphMap);\r\n                }\r\n                for(const neiId of incomingAdjList.get(nodeId)){\r\n                    dfs(neiId, graphMap);\r\n                }\r\n\r\n                return graphMap;\r\n            }\r\n\r\n            for(const node of rootNode.nodes || []){\r\n                const nodeId = node.id;\r\n\r\n\r\n                if(visited.has(nodeId)) continue;\r\n                components.push(dfs(nodeId, new Map()));\r\n            }\r\n\r\n            return components;\r\n        }\r\n\r\n        const createAdjList = (nodeNameToId) => {\r\n            const adjList = new Map();\r\n\r\n            for(const node of rootNode.nodes || []){\r\n                adjList.set(node.id, new Set());\r\n            }\r\n\r\n            for(const edge of rootNode.edges || []){\r\n                const sourceId = nodeNameToId.get(edge.source);\r\n                const targetId = nodeNameToId.get(edge.target);\r\n\r\n                if(sourceId === undefined || targetId === undefined) continue;\r\n\r\n                adjList.get(sourceId).add(targetId);\r\n            }\r\n\r\n            return adjList;\r\n        };\r\n\r\n        const createIncomingAdjList = (nodeNameToId) => {\r\n            const adjList = new Map();\r\n\r\n            for(const node of rootNode.nodes || []){\r\n                adjList.set(node.id, new Set());\r\n            }\r\n\r\n            for(const edge of rootNode.edges || []){\r\n                const sourceId = nodeNameToId.get(edge.source);\r\n                const targetId = nodeNameToId.get(edge.target);\r\n\r\n                if(sourceId === undefined || targetId === undefined) continue;\r\n\r\n                adjList.get(targetId).add(sourceId);\r\n            }\r\n\r\n            return adjList;\r\n        };\r\n\r\n        const createFASGraph = (adjList, incomingAdjList) => {\r\n            const visited = new Set();\r\n\r\n            const dfs = (nodeId) => {\r\n\r\n                if(visited.has(nodeId)){\r\n                    greedyMakeAcyclic(nodeId, adjList, incomingAdjList);\r\n                }\r\n                visited.add(nodeId);\r\n\r\n                for(const targetId of adjList.get(nodeId) || []){\r\n                    dfs(targetId);\r\n                }\r\n            }\r\n\r\n\r\n            for(const nodeId of adjList.keys()){\r\n                if(visited.has(nodeId)) continue;\r\n\r\n                dfs(nodeId);\r\n            }\r\n\r\n            return adjList;\r\n        }\r\n\r\n        const greedyMakeAcyclic = (nodeId, adjList, incomingAdjList) => {\r\n            const outgoingEdges = adjList.get(nodeId);\r\n            const incomingEdges = incomingAdjList.get(nodeId);\r\n\r\n            // np O (n + m) where n is incoming and m is outgoing\r\n\r\n            if(outgoingEdges.length > incomingEdges.length){\r\n                // flip incoming to outgoing\r\n                for(const incomingId of incomingEdges){\r\n                    // remove incoming edge\r\n                    adjList.get(incomingId).delete(nodeId);\r\n                    // add new outgoing in place\r\n                    adjList.get(nodeId).add(incomingId);\r\n                }\r\n            }\r\n            else{\r\n                // flip outgoing to incoming\r\n                for(const outgoingId of outgoingEdges){\r\n                    // remove outgoing edge\r\n                    adjList.get(nodeId).delete(outgoingId)\r\n\r\n                    // add new incoming in place\r\n                    adjList.get(outgoingId).add(nodeId);\r\n                }\r\n            }\r\n        }\r\n\r\n        const assignLevel = (adjList) => {\r\n\r\n            const topologicalSort = () =>{\r\n                const inDegree = new Map();\r\n                for(const nodeId of adjList.keys()){\r\n                    inDegree.set(nodeId, 0);\r\n                }\r\n    \r\n                for(const neiIdSet of adjList.values()){\r\n                    for(const neiId of neiIdSet){\r\n                        inDegree.set(neiId, inDegree.get(neiId) + 1);\r\n                    }\r\n                }\r\n    \r\n                const queue = new Queue();\r\n    \r\n                for(const nodeId of inDegree.keys()){\r\n                    if(inDegree.get(nodeId) === 0) queue.push(nodeId);\r\n                }\r\n    \r\n                const topologicalOrder = [];\r\n    \r\n                while(!queue.isEmpty()){\r\n                    const nodeId = queue.pop();\r\n    \r\n                    topologicalOrder.push(nodeId);\r\n    \r\n                    for(const neiId of adjList.get(nodeId)){\r\n                        inDegree.set(neiId, inDegree.get(neiId) - 1);\r\n                        if(inDegree.get(neiId) === 0){\r\n                            queue.push(neiId);\r\n                        }\r\n                    }\r\n                }\r\n    \r\n                return topologicalOrder;\r\n            }\r\n\r\n            // use kahns algorithm to process nodes by level\r\n            const topoSorted = topologicalSort();\r\n\r\n\r\n            // assign levels to nodes\r\n            const levels = new Map();\r\n\r\n            for(const nodeId of topoSorted){\r\n                let maxPredLevel = -1;\r\n\r\n                for(const pred of adjList.keys().filter(n => adjList.get(n).has(nodeId))){\r\n                    if(levels.get(pred) > maxPredLevel){\r\n                        maxPredLevel = levels.get(pred);\r\n                    }\r\n                }\r\n\r\n                levels.set(nodeId, maxPredLevel + 1);\r\n            }\r\n\r\n            return levels;\r\n        }\r\n\r\n        if(rootNode) calculatePositions();\r\n        // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    }, [rootNode])\r\n\r\n\r\n    return (\r\n        <div ref={renderer} id='renderer' style={rendererStyle}>\r\n            <Viewport></Viewport>\r\n            <svg xmlns='http://www.w3.org/2000/svg' preserveAspectRatio='xMidYMid meet' viewBox={`0 0 ${renderer.current?.offsetWidth} ${renderer.current?.offsetHeight}`}  id='edge-container'>\r\n                {formattedEdgeData.length > 0 && (formattedEdgeData || []).map((edge, i) => <Edge key={i} data={edge}/>)}\r\n            </svg>\r\n            <div id='node-container'>   \r\n                {formattedNodeData.length > 0 && (formattedNodeData || []).map((node, i) => <Node key={i} data={node} />)}\r\n            </div>\r\n            <canvas id='text-calculator' ref={textRuler}></canvas>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Renderer;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}